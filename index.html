<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Joachim Mero</title></title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <script src="index.js"></script>
    <div>14.1.2025</div>
    <div>
		<div>
			How to know what is a business-rule is and what isn't?
		</div>
		<div>
			I'm currently extending our game and I'm facing an interesting problem: I need to figure out whether the I should extend a business-rule or implement the change in some other way.
    	I first started changing the business-rule. I stated that the existing rule is only true when the game is in a specific state (I added an early exit). Soon after, though, after showing the change to our UX-designer, I noticed that the change didn't quite result in what I was expecting. In turned out that the states of our game are less granular than I originally thought.
    What I then did was, yet again, go back to change the business-rule. I stopped, because that didn't feel quite right. I realized that the rule I was meaning to add would've been very presentation-specific: "the business-rule is only true when in this or that state _and_ when state is in this sub-state", and that sub-state even existing is very much a detail of the presentation, and could as well not be there. .Yeah not doing that.
    So in this very specific case the "when should I apply this business-rule" is a presentational concern, not a business-rule, and so it shouldn't be applied in the business-rules, but rather somewhere in the presentation-layer.
    For some reason I didn't realize that first, but it would be beneficial to build that muscle. I'm not sure how though. What are the things that distinct a business-rule from a presentational concern? Maybe the "when should I show" is one. Thoughts?
		</div>
    </div>
    <div>9.1.2025</div>
    <div>I was tasked today at work to implement a change in design in one critical game-system in our game. At first I thought I would've gone in and modify the existing systems to support the new requirements, but after thinking about it a little bit I decided not to. I remembered that a couple of months ago that same game-system was just modified, due to a similar change in it's feature's requirements. Now I was tasked to basically revert those changes.
    	I thought that what I would do instead would be to implement the change in a modular fashion, where I wouldn't lose the existing code and its integration-details. I extracted the existing system into a component and hid it behind an abstraction. After that I implemented the change as a separate component, following the same abstraction, and swapped it in the place of the current one.
    	This kind of refactor-first kind-of change makes a lot of sense, because I made the system extensible in the place that I witnessed being changed regularly, but when would this approach not be viable? That's something I'd like to discuss with some one.
	If you're interested, you can reach out to me at developer.madeforme@gmail.com
	</div>
	<div>19.1.2026</div>
	<div>
		<div>
			AI Agents and Being Uneasy			
		</div>
		<div>
			Being certain about the changes I make in code is very important to me. That’s reflected in the way I work, from writing simple and easily reasonable code to structuring commits in a clear way to have visibility on what I have changed. This way of working is deeply rooted in me and I benefit from it greatly.

However, that mentality causes issues when using AI for coding. I have been wondering why I get the feeling that something’s off when asking AI to solve some problems. This is the reason. I know deep inside that I’m entering a dangerous territory. I know I’m sacrificing understanding for speed. It’s simply impossible for me to reach the same level of understanding, and with that confidence, of a problem or the solution when using AI. Not even if I read all of the code it generates. I have to play with code to gain it.

This doesn’t mean that I wouldn’t use AI for anything, but it does give me a better sense of the problems to use it for. Problems that I have already solved a million times, or problems I already know the exact solution to, I will use AI to solve. I will use it as a super-powered auto-completion. However, I will not ask it to write new code or to fix an issue that I don’t yet understand.

It’s clear that with AI we’ve entered a new realm to learn to live in. 
		</div>
</div>
  </body>
</html>
